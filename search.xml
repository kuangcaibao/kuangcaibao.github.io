<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[sublime-text 使用记录]]></title>
      <url>%2F2017%2F04%2F11%2Fsublime-text-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[介绍使用 sublime text 的过程中个人认为不错的技巧 sublime-text3 中，程序默认装了一些 packages，放在安装目录下的 packages 下。然后我们后续安装的包，会放在 Preferences -&gt; Browse Packages... 打开的目录下。 这里的包一般都是 [包名].sublime-package，这里可以用压缩文件打开，会发现里面有配置文件。我们可以修改那里的配置文件，来达到我们配置包的目的。 1. 安装 packages下载的 sublime text3 默认是没有 install package 操作，安装这个功能。Ctrl + ` 打开控制台，然后输入： 1import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 1.1 tab 占位大小设置tab 大小默认为 4 个空格，这里我习惯设置 tab 为 2 个空格大小。preferences -&gt; settings 打开文件 Preferences.sublime-settings User 并添加内容 1234&#123; &quot;tab_size&quot;: 2, &quot;translate_tabs_to_spaces&quot;: true,&#125; 具体说明 2. 快捷键Ctrl + ` 呼出控制台 Ctrl + shift + P 调出 package control 命令 Ctrl + P 输入文件名，打开改文件 3. 不错的 packages这里介绍经常用到的一些 sublime 插件，安装步骤和使用说明 点这里 ctrl + shift + p 进入 package control 控制输入框 输入你要安装的 package 名称，等待安装完成 配置 package 3.1 OmniMarkupPreviewermarkdown 预览插件。 ctrl + alt + o 在浏览器中预览 md 文件， ctrl + alt + x 生成 html 文件。 3.2 Nodejs这里我们执行 ctrl + b 命令，发现命令窗口中显示的是乱码。怎么修改？ 网上的做法是修改 Nodejs.sublime-build 文件，这个文件在哪？ 找了一圈都没有看到，并且从 sublime 的 Preferences -&gt; Package Settings -&gt; Nodejs -&gt; Settings User 来打开配置文件，发现打开的是 Nodejs.sublime-settings 文件，这里没有 encoding 配置。 Preferences -&gt; Browse Packages ... 打开我们安装包的路径，目录截图如下： 这里看到没有我们安装的 Nodejs，找不到。上一级目录下有个 Installed Packages 目录中会发现 Nodejs.sublime-package 文件，我们解压这个文件，会发现有文件 Nodejs.sublime-build，我们修改其中的内容，把 encoding 值改为 utf8。重启 sublime text，会发现我们的编码问题解决。 网上还有需要改 cmd 这些配置，个人猜想可能是 path 环境路径中没有加入 nodejs 的安装目录，导致 shell 执行 node $file 会报错，但是这里我们安装 nodejs 的时候，这些环境都安装了，所以可以执行了。 3.3 运行 Java我们在 sublime-text3 中看到了 build 项中有 java。我们写一个 Test.java 文件，然后执行 ctrl + b 命令，可以看到在 java 文件对应的目录下生成了一个 class 文件，但是这里我们缺少输出。 修改 C:\Program Files\Sublime Text 3\Packages\Java.sublime-package 中的 JavaC.sublime-build 文件。内容如下 123456&#123; - &quot;shell_cmd&quot;: &quot;javac \&quot;$file\&quot;&quot;, + &quot;shell_cmd&quot;: &quot;runJava.bat \&quot;$file\&quot;&quot;, &quot;file_regex&quot;: &quot;^(...*?):([0-9]*):?([0-9]*)&quot;, &quot;selector&quot;: &quot;source.java&quot;&#125; 代码中前面的 - 表示删除那一行，+ 表示添加那一行 1234567891011// runJava.bat@ECHO OFFcd %~dp1IF EXIST %~n1.class (DEL %~n1.class)javac -encoding UTF-8 %~nx1IF EXIST %~n1.class (java %~n1) 具体做法参考 4. 附录：一些问题4.1 package install 报错报错信息为 1Package Control: Error downloading channel. URL error unknown error (_ssl.c:2228) downloading https://packagecontrol.io/channel_v3.json fixed: preferences -&gt; Browse Packages... 进入 User 目录，删除目录下的 Package Control.merged-ca-bundle 和 Package Control.user-ca-bundle 文件。具体说明]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义弹出层问题]]></title>
      <url>%2F2017%2F03%2F29%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%B9%E5%87%BA%E5%B1%82%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[1. 简单示例代码一个简单的示例弹出层代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// index.html&lt;html&gt;&lt;head&gt; &lt;title&gt;弹出层&lt;/title&gt; &lt;meta charset=utf-8&gt; &lt;meta name=description content=&quot;弹出层&quot;&gt; &lt;meta name=viewport content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .modal &#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: #000; opacity: 0.6; z-index: 1000; &#125; .modal-detail &#123; width: 400px; height: 300px; background-color: #fff; color: #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;p&gt;测试文本信息测试文本信息测试文本信息测试文本信息测试文本信息&lt;/p&gt; &lt;div class=&quot;modal&quot;&gt; &lt;div class=&quot;modal-detail&quot;&gt; &lt;p&gt;这是一个弹出层信息&lt;/p&gt; &lt;button&gt;这是一个按钮&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 浏览器中打开的效果图如下： 2. 弹出层内容透明这个是因为 opacity 这个属性，被子节点继承了，也就是说 modal-detail 节点的 opacity 属性也是透明的。如何解决这个问题，我们改掉父节点的写法。 123456.modal &#123; ... /*background-color: #000; opacity: 0.6;*/ background: rgba(0, 0, 0, 0.6);&#125; 至于为什么我们重新设置 .modal-detail 中的属性 opacity: 1, 背景还是透明的，这个不知道原因。 3. modal 节点 position 的问题上面设置的 position: fixed; 这个显示是正常的。如果把这个属性改成 position: absolute;，当 p 中的内容触发浏览器窗口出现滚动的时候。这个时候弹出层，会发现只覆盖了最上面的一屏幕区域，下面的滚动区域没有覆盖到，具体效果自己可以测试看看。 4. 总结.modal 的这个节点的 css 样式要注意 2 个地方： position: fixed; background-color, opacity 这个组合设置背景透明遮罩效果改成 background: rgba(...)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端培训（2）]]></title>
      <url>%2F2017%2F03%2F18%2F%E5%89%8D%E7%AB%AF%E5%9F%B9%E8%AE%AD%EF%BC%882%EF%BC%89%2F</url>
      <content type="text"><![CDATA[1. nodejs 环境准备osx, linux 环境下安装，自行谷歌或者点击这里 windows 下安装，和一般的 exe 一样。 官方地址 检查环境是否正常，在 dos 窗口中分别执行下面命令。 &gt; node -v &gt; npm -v 如果安装成功，会分别提示 2 个工具的版本信息。 npm 是一个 js 插件的包管理工具，默认的源为 https://registry.npmjs.org/。由于网络环境问题，需要把源修改成国内的源。 对应命令： &gt; npm config get registry &gt; npm config set registry=http://registry.npm.taobao.org 2. git 工具安装工具下载地址：点击下载 代码版本管理工具 git, 入门介绍： Git 工作流程 Git 使用规范流程 Git教程 Git详细介绍 常用 git 命令： &gt; git clone &gt; git status &gt; git add &gt; git reset &gt; git commit &gt; git checkout &gt; git push &gt; git pull &gt; git fetch &gt; git remote 3. 常见的一个 nodejs 项目有个什么样的文件目录结构执行命令：npm init, 按照提示一路 enter，然后会在当前目录下产生一个 package.json 文件。 { &quot;name&quot;: &quot;react-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;node server.js&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: {}, &quot;devDependencies&quot;: {} } 这个文件就是 npm 包管理工具管理包依赖的文件和一些脚本配置文件。想象一下，不管是我们自己创建一个空的工程，还是 clone 别人的项目，基本上第一步都是安装依赖包。这个包的依赖关系，就是 package.json 文件配置。 dependencies, devDependencies 这里说明我们依赖的库，一般不用直接配置，使用 npm install --save 或者 npm install --save-dev 来添加并安装包。 所以一般的命令流程是这样的，以 react, webpack 等等环境准备为例 &gt; npm init &gt; npm install --save react react-dom 上述命令添加了 react, react-dom，这时我们的 package.json 文件内容增加了： { ... &quot;dependencies&quot;: { &quot;react&quot;: &quot;^15.4.2&quot;, &quot;react-dom&quot;: &quot;^15.4.2&quot; } } 同时在当前目录下会产生一个 node_modules 文件夹，这个文件夹下的内容就是我们下载下来的包。 这里 npm install [包名]@[版本] [配置] 常用配置： -g 全局安装，全局命令 --save 添加包依赖到 package.json 文件的 dependencies --save-dev 添加包依赖到 package.json 文件的 devDependencies 这个命令的详细介绍，点击这里 经常性看到工程项目下有一些其他的配置文件，如 .gitignore, .eslintrc, .babelrc 这些。这是使用对应工具的默认读取配置文件。 4. 示例代码示例项目地址 https://github.com/kuangcaibao/react-demo.git 如何运行工程： git clone https://github.com/kuangcaibao/react-demo.git react-democd react-demonpm installnpm start 这里还有另外一个分支，为 todolist 的简单代码实现，运行方式： git checkout todolistnpm start 这个里面使用 webpack 仅仅只是使用了 babel-loader 来处理 js 文件。可以尝试下引入一个 css 文件来为 todolist 增加样式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端培训]]></title>
      <url>%2F2017%2F03%2F14%2F%E5%89%8D%E7%AB%AF%E5%9F%B9%E8%AE%AD%2F</url>
      <content type="text"><![CDATA[前端3要素：html, js, css api 说明，或者查询定义网站 mdn 1. htmlhtml 结构 &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; html 头部，以前有个 !doctype, 指定渲染 html 遵循的标准。现在都是直接写 html，遵循最新的 html5 语法标准。 w3.org html 头部标准 html head 元素头部说明 如何引入 javascript, css。 外部引用 js: &lt;script type=&quot;text/javascript&quot; src=&quot;[your js link]&quot;&gt;&lt;/script&gt; HTML中: &lt;script&gt;[your code]&lt;/script&gt; 外部 css: &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;[your css link]&quot;&gt; HTML 中：&lt;style&gt;[your css code]&lt;/style&gt; 树状结构 介绍下 Element, Node 2. css定义 html 中标签的样式。 盒模型，浮动 float 弹性布局 flex css 模块化 @import 或者三方工具 3. js操作 dom 树，改变 dom 结构。 作用域，变量命名空间，原型 prototype 4. 模块化解决什么问题提出的 规范： AMD, CMD, CommonJS 介绍说明 AMD) CMD CommonJS 就是模块的定义写法，和引用方式有些区别。 解决方案：seajs(CMD), requirejs(AMD), nodejs(CommonJS) CMD, CommonJS 加载规则不同，CMD可以是异步的, CommonJS同步加载 5. nodejsnodejs 使得前端真正强大起来。 npm 包管理器 6. 字符串模板插件doT.js artTemplate 初步的数据和模板分离，自己手动刷新。。。 写在 html 里面，虽然方便，但是如果应用复杂后，html 内容变得太多，需要分成不同的块。 或者写成字符串模板，放在 js 中。 前端框架：reactjs, vue, angularjs 6. reactjsjsx 语法 第一个 react 示例 这里就需要考虑业务模型，然后拆分不同模块形成组件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于 mouseenter, mouseleave 的一个奇怪现象]]></title>
      <url>%2F2017%2F03%2F08%2F%E5%85%B3%E4%BA%8Emouseenter%E5%92%8Cmouseleave%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%8E%B0%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[今天在处理 mouseenter, mouseleave 时，发现一个奇怪的现象。 reproduction，点击这里 触发 mouseenter 事件，是在鼠标进入 box1 框中，符合预期。但是触发 mouseleave 事件，却是在鼠标离开下方边框，然后再下面一段距离才行，这个就不符合预期了。 但是如果把代码中的，这行注释掉，那么2个事件的表现就都符合预期了。 12$(&quot;#box3&quot;).stop().fadeIn(100);// $(&quot;#box3&quot;).css(&#123;&quot;display&quot;: &quot;inline-block&quot;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git submodule 测试]]></title>
      <url>%2F2017%2F03%2F04%2Fgit-submodule-%E6%B5%8B%E8%AF%95%2F</url>
      <content type="text"><![CDATA[1. 前言在做 github pages 工程多端同步的时候，我们在我们的主工程下面 clone 了一个子工程，如 themes/next。当使用 git push origin master 提交我们的 blog 内容修改的时候，可以在远程仓库中 themes/next 下的内容为空，没有同步。 网上解释这个现象的关键词 git submodule, 官方的解释说明，点击这里 2. 测试 git submodule 工作现象2.1 裸仓库和一般仓库的区别裸仓库和一般的 git 仓库有什么区别？主要有下面2点： 裸仓库没有工作区，一般 git 仓库有工作区 执行 git push 命令，可以推送修改到裸仓库，而一般的仓库不能被推送 说到推送，向一般的 git 仓库执行 git push，会提示： 12! [remote rejected] master -&gt; master (branch is currently checked out)error: failed to push some refs to &apos;E:/git-submodule-test/main/&apos; 看到这里就理解了2者区别。 2.2 创建2个裸仓库，并向仓库推送修改执行命令： 1234567891011$ mkdir main$ cd main$ git init$ cd ../$ git clone --bare main main.git$ mkdir sub$ cd sub$ git init$ cd ../$ git clone --bare sub sub.git 至此，我们成功建立了2个裸仓库：main.git 和 sub.git。 1234$ rm -rf main$ rm -rf sub$ git clone main.git main$ git clone sub.git sub clone 2个一般仓库，并添加内容，提交到对应的裸仓库中。 2.3 从主仓库开始我们现在有2个仓库，下面开始我们一般的工作流程： clone 一个仓库代码到本地 在这个仓库下面，再 clone 一个仓库代码 对应的执行代码： 123$ git clone main.git ztest1$ cd ztest1$ git submodule add ../sub.git sub 这时我们可以看到 ztest1 目录下多了 .gitmodules 文件，多了 sub 文件夹。执行 git status，显示内容： 12345678$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: .gitmodules new file: sub 提交修改到 main.git。 1234567891011121314$ git commit -m &quot;first post&quot;[master 3fb2def] first post 2 files changed, 4 insertions(+) create mode 100644 .gitmodules create mode 160000 sub$ git push origin masterCounting objects: 3, done.Delta compression using up to 8 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 353 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To E:/git-submodule-test/main.git/ 607e63d..3fb2def master -&gt; master 我们看看效果。 1$ git clone main.git ztest2 这里可以看到 main.git 中的内容回来了，但是 sub 下面没有内容。这里我们要取回这个内容。 1234567$ git submodule initSubmodule &apos;sub&apos; (E:/git-submodule-test/sub.git) registered for path &apos;sub&apos;$ git submodule updateCloning into &apos;E:/git-submodule-test/ztest2/sub&apos;...done.Submodule path &apos;sub&apos;: checked out &apos;9f2f93760733ede5a1e30ccd4b6e0450fd60e221&apos; 到这里，我们的 sub 内容返回了。 2.4 操作子仓库上面的步骤中，我们知道怎么获取2个仓库的内容。假设下下面的场景: 我自己在本地修改了 sub 中的内容，如何推送到服务端，这样别人可以更新 别人已经推送到服务端远程仓库的修改，我在这边如何同步 对于场景1，我们可以这样模拟，在 ztest1 中的 sub 下修改内容。我们在 ztest1 路径下执行下面操作： 123456789101112131415161718$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: sub (modified content)$ git add .$ git commit -m "change sub"On branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit: modified: sub (modified content)no changes added to commit 可以看到 ztest1 这个仓库操作不了 sub 下的内容，我们进入 sub 路径下执行下面操作： 123456789101112131415161718192021222324$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: helloworld.mdno changes added to commit (use "git add" and/or "git commit -a")$ git add .$ git commit -m "change sub"[master bf7521b] change sub 1 file changed, 3 insertions(+), 1 deletion(-)$ git push origin masterCounting objects: 3, done.Delta compression using up to 8 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 293 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To E:/git-submodule-test/sub.git 9f2f937..bf7521b master -&gt; master 这里我们把修改，推送到远程仓库了。下面我们在 ztest2 中来同步这个修改，到 ztest2/sub 目录下，执行操作： 1234567$ git pull origin masterFrom E:/git-submodule-test/sub * branch master -&gt; FETCH_HEADUpdating 9f2f937..bf7521bFast-forward helloworld.md | 4 +++- 1 file changed, 3 insertions(+), 1 deletion(-) 这里看到同步了。 3. 结果说明使用 git submodule 虽然管理了多个子仓库，但是每个子仓库的操作都是各自操作。唯一和一般的仓库使用区别是，在 git clone 主仓库后，我们需要执行： 12$ git submodule init$ git submodule update 操作来更新我们子项目代码内容，其他的没有什么区别。 2017-04-07 具有 submodule 的仓库，当我们 clone 主仓库后，执行 12&gt; git submodule init&gt; git submodule update 操作后，这里会自动同步子仓库内容，当然不是同步远程的子仓库内容。这个说法是什么意思呢？ 我们操作子仓库，然后经过 git commit 后会生成一个版本号，这个版本号我们需要在主仓库中也要 git commit 一次。这个时候，主仓库会记录子仓库中他需要的版本号。所以执行 git submodule update 操作，这个时候其实做的操作是拿着主仓库中记录的子仓库的版本号，去把对应的子仓库版本下载下来。 怎么理解？ 4. 再总结4.1 git submodule update 报错我们执行 git clone 把主仓库克隆下来，然后按照教程顺序执行 git submodule init 和 git submodule update 操作，这个时候，可能会提示 ref 和子版本的引用不一致，导致下载子仓库失败。为什么？？？ 我在子仓库中的修改，没有 push 到远程仓库中，导致在另一个机器上克隆时，会发现远程子仓库中的版本和主仓库中记录的版本，不一致，准确的说是不存在。所以那个版本的内容没有，导致下载失败。 4.2 测试示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657kcb@kcb-PC MINGW64 /e$ mkdir git-submodule-testkcb@kcb-PC MINGW64 /e$ cd git-submodule-test/kcb@kcb-PC MINGW64 /e/git-submodule-test$ mkdir mainkcb@kcb-PC MINGW64 /e/git-submodule-test$ cd mainkcb@kcb-PC MINGW64 /e/git-submodule-test/main$ git initInitialized empty Git repository in E:/git-submodule-test/main/.git/kcb@kcb-PC MINGW64 /e/git-submodule-test/main (master)$ cd ../kcb@kcb-PC MINGW64 /e/git-submodule-test$ mkdir subkcb@kcb-PC MINGW64 /e/git-submodule-test$ cd subkcb@kcb-PC MINGW64 /e/git-submodule-test/sub$ git initInitialized empty Git repository in E:/git-submodule-test/sub/.git/kcb@kcb-PC MINGW64 /e/git-submodule-test/sub (master)$ cd ../kcb@kcb-PC MINGW64 /e/git-submodule-test$ git clone --bare main/ main.gitCloning into bare repository &apos;main.git&apos;...warning: You appear to have cloned an empty repository.done.kcb@kcb-PC MINGW64 /e/git-submodule-test$ git clone --bare sub/ sub.gitCloning into bare repository &apos;sub.git&apos;...warning: You appear to have cloned an empty repository.done.kcb@kcb-PC MINGW64 /e/git-submodule-test$ cd mainkcb@kcb-PC MINGW64 /e/git-submodule-test/main (master)$ git remote -vkcb@kcb-PC MINGW64 /e/git-submodule-test/main (master)$ git remote add origin ../main.gitkcb@kcb-PC MINGW64 /e/git-submodule-test/main (master)$ git remote -vorigin ../main.git (fetch)origin ../main.git (push) 至此，我们建立了 2 个裸仓库，并且各自有一个仓库来提交修改。我们在 main 和 sub 中分别添加内容，然后提交到本地仓库同时推送到远程仓库中，这里是 main.git 和 sub.git。 建立第一个带 sub 的实例。 123456789101112131415161718192021222324252627282930313233343536373839kcb@kcb-PC MINGW64 /e/git-submodule-test$ git clone main.git/ ztest1Cloning into &apos;ztest1&apos;...done.kcb@kcb-PC MINGW64 /e/git-submodule-test$ cd ztest1/kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git submodule add ../sub.git subCloning into &apos;E:/git-submodule-test/ztest1/sub&apos;...done.warning: LF will be replaced by CRLF in .gitmodules.The file will have its original line endings in your working directory.kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: .gitmodules new file: subkcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git commit -m &quot;ztest1 添加 sub&quot;[master f416ded] ztest1 添加 sub 2 files changed, 4 insertions(+) create mode 100644 .gitmodules create mode 160000 subkcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 1 commit. (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean 至此，ztest1 中的文件结构 12345/ztest1 .gitmodules main.txt /sub sub.txt 2 个仓库的内容都克隆下来了。我们在 ztest1 中修改 main.txt 和 sub.txt 内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 1 commit. (use &quot;git push&quot; to publish your local commits)Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: main.txt modified: sub (modified content)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 1 commit. (use &quot;git push&quot; to publish your local commits)Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: main.txtChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: sub (modified content)kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git commit -m &quot;ztest1 main.txt change&quot;[master 7ece350] ztest1 main.txt change 1 file changed, 3 insertions(+), 1 deletion(-)kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) (commit or discard the untracked or modified content in submodules) modified: sub (modified content)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ cd sub/kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1/sub (master)$ git add .kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1/sub (master)$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: sub.txtkcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1/sub (master)$ git commit -m &quot;ztest1 sub.txt change&quot;[master 22d4842] ztest1 sub.txt change 1 file changed, 3 insertions(+), 1 deletion(-)kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1/sub (master)$ cd ../kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: sub (new commits)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git add .kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: subkcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git commit -m &quot;ztest1 main submit sub&quot;[master ca2a14b] ztest1 main submit sub 1 file changed, 1 insertion(+), 1 deletion(-)kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ git push origin masterCounting objects: 8, done.Delta compression using up to 8 threads.Compressing objects: 100% (7/7), done.Writing objects: 100% (8/8), 917 bytes | 0 bytes/s, done.Total 8 (delta 1), reused 0 (delta 0)To E:/git-submodule-test/main.git/ ef7567f..ca2a14b master -&gt; master 这里我们只是在 ztest1 下把内容推送到 mian.git 中了。我们这里执行下面操作 1234567891011121314151617181920kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ cd ../kcb@kcb-PC MINGW64 /e/git-submodule-test$ git clone main.git ztest2Cloning into &apos;ztest2&apos;...done.kcb@kcb-PC MINGW64 /e/git-submodule-test$ cd ztest2kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest2 (master)$ git submodule initSubmodule &apos;sub&apos; (E:/git-submodule-test/sub.git) registered for path &apos;sub&apos;kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest2 (master)$ git submodule updateCloning into &apos;E:/git-submodule-test/ztest2/sub&apos;...done.Fetched in submodule path &apos;sub&apos;, but it did not contain 22d484273b4dca3fe105251fde9885af436d73ac. Direct fetching of that commit failed. 这里看到的提示信息是什么，sub 中不包含版本 22d484273b4dca3fe105251fde9885af436d73ac。失败了，这个是因为我们没有把我们的 sub 修改推送到 sub 中。 123456789101112131415161718192021222324252627282930313233343536373839kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest2 (master)$ cd ../ztest1/sub/kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1/sub (master)$ git push origin masterCounting objects: 3, done.Delta compression using up to 8 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 320 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To E:/git-submodule-test/sub.git d3386e7..22d4842 master -&gt; masterkcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1/sub (master)$ cd ../kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest1 (master)$ cd ../kcb@kcb-PC MINGW64 /e/git-submodule-test$ git clone main.git ztest3Cloning into &apos;ztest3&apos;...done.kcb@kcb-PC MINGW64 /e/git-submodule-test$ cd ztest3kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest3 (master)$ git submodule updatekcb@kcb-PC MINGW64 /e/git-submodule-test/ztest3 (master)$ git submodule initSubmodule &apos;sub&apos; (E:/git-submodule-test/sub.git) registered for path &apos;sub&apos;kcb@kcb-PC MINGW64 /e/git-submodule-test/ztest3 (master)$ git submodule updateCloning into &apos;E:/git-submodule-test/ztest3/sub&apos;...done.Submodule path &apos;sub&apos;: checked out &apos;22d484273b4dca3fe105251fde9885af436d73ac&apos; 这里就可以很明白的看清楚了，主仓库中记录子仓库的版本，我们在执行 git submodule update 时，拉取的对应子仓库版本中的版本号。至此 git submodule 的表现情形测试清楚了。 各个版本各自更新 主仓库会把子仓库的修改也要 commit 一遍，主要是版本号信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[创建自己的 github.io 站点页面]]></title>
      <url>%2F2017%2F02%2F28%2F%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%20github.io%20%E7%AB%99%E7%82%B9%E9%A1%B5%E9%9D%A2%2F</url>
      <content type="text"><![CDATA[1. 为什么使用 github.io 提供的静态页面服务写 blog 三方网站（如 oschina.net, segmentfault.com, csdn.net 等）提供的 blog 系统，虽然可以记录 blog。因为托管在第三方，经常容易忘记，然后就没有然后了。github.com 是一个免费的代码托管平台，可以托管你的代码和平常的记录，支持markdown 语法记录，非常方便。 但是在 github.com 上查看自己的 markdown 文件内容，虽然渲染成了页面，显示也很友好，但是没有归档功能，查找其他不方便。 github pages 提供的是一个静态页面服务，github.com 上的每个开发者都有一个域名来使用它的静态网页服务，地址类似 username.github.io。免费域名，免费提供站点服务，非常方便，同时自己管理自己的内容。 2. 使用 hexo 来创建一个 github pagesgithub pages 官方推荐的主题是 ruby 实现的，使用起来看不懂。这里推荐一个 hexo，一个基于 nodejs 的工具。 使用起来还是比较方便的。 这里假设你完成了一下的准备： 系统安装了 node, git 在 github.com 上创建了一个仓库 username.github.io.git 在你的系统和 github 间建立了一个 ssh 通路 这时按照 hexo 的教程，来创建。 1234&gt; npm install -g hexo-cli&gt; hexo init blog-test&gt; cd blog-test&gt; hexo server 执行完这些命令后，你在本地启动了 hexo server 服务，可以在浏览器中输入地址查看内容。通过修改配置来设置你的站点的一些配置参考官方文档。这个配置最好和后面的主题一起看。 在浏览器中输入本机测试地址，看到有个 hello world 的例子，到这里。你的 hexo 站点在本地可以正常运行了。下一步我们需要做什么？ github pages 是一个静态页面服务器，理解起来就是它提供的内容就是 html + css + js 这样的形式组织的页面。所以下一步，我们需要生成静态页面，然后发布到我们 github.com 对应的仓库中，执行下面的命令： 12&gt; hexo generate&gt; hexo deploy 这里在 deploy 的过程中，我们需要配置我们 git 仓库的地址。配置文件 _config.yml 1234deploy: type: git repo: git@github.com:kuangcaibao/kuangcaibao.github.io.git 官方文档，推荐的是 https 这种协议的，使用这种协议 git push 的时候，会提醒用户名不存在，报错。 我们换成 git 协议，也就是地址类似上方那种协议。但是有时也会报错，说没有权限操作远程仓库，这种情形也是昨天遇到的。查询下资料，试了换协议，重新生成 ssh key 等。最后发现是我的 git for windows 版本低了，有这个 bug，新的 git for windows 版本没有这个问题，果断升级后成功 deploy 了。 到这里，可以在浏览器输入 username.github.io，来访问你的页面。如果有内容，到此配置都没有问题了。 3. 将 hexo 的主题换为 nextgoogle 一下 hexo 流行的主题，第一条推荐是 hexo-theme-next，就是用这个主题了。 hexo 主题存放路径 /themes/[theme type]，配置为文件 _config.yml 中的 theme: [type]。 在这里，我们 git clone 主题 hexo-theme-next 的内容到对应的文件夹下。 1&gt; git clone https://github.com/iissnan/hexo-theme-next.git themes/next 修改配置文件 _config.yml 中内容 theme: next 这个时候，重启服务器 hexo server，来查看效果。 hexo-theme-next 的配置，参考其官方文档 4. 多端同步我们的内容前面介绍了几个概念： github pages 是一个静态网页服务器，所以对应我们仓库中的文件内容都是一些静态 html css 文件。 hexo 是使用模板来生成 html 页面，就是说，我们的内容其实是 md 格式的文件。 这样，使用命令 hexo deploy 只是将生成的静态页面文件 push 到了我们的仓库中。实际的源文件，没有处理。 所以这里，我们需要把我们的源文件，就是工程文件也上传到 github 中。理解了这个过程，那么我们就好管理了，不管是再新建一个仓库，来存放这些文件。还是在 github pages 的那个仓库下建一个分支来存放文件，都行。 5. hexo-theme-next 继承第三方服务5.1 评论系统这里选择 官方文档 中推荐的 多说。然后按照文档说明，注册信息和在站点配置文件中配置对应的内容就可以了。 最近多说评论系统要被关闭了，现在把评论系统切换到 Disqus 上。切换步骤： 在 Disqus 官网 上注册一个账号 然后进入个人设置中心，选择 add disqus to site 进入 install disqus 页面 选择选项 i want to install disqus on my site 按照提示创建 创建成功后，然后根据 hexo-theme-next 介绍配置，在 主题配置文件 中把这个打开。 到此，评论系统配置成功。不过不能微信，QQ 登录，这个有点伤。 5.2 图片存储服务如果把 blog 中图片资源也放到 github 中，很容易把 github 的免费空间耗完。所以这里把文件上传到第三方云存储上去，直接引用链接。 在 七牛 上注册账号，开始操作，操作方式自行 google。 这种方式的弊端，就是使用图片前，要把图片上传到七牛空间，然后获取到资源链接，在 markdown 文本中使用 ![]() 这种方式引用。这种过程都是手动完成，繁琐不方便，有没有好的方法??? 点这里! 再点击这里!!! 使用第2种方式，虽然配置有些复杂，但是要比方式1方便很多，好处自己体会！！！ 使用方式2有个坑，试试吧。解释点击这里 6. Q &amp; A6.1 next 主题修改配置的同步问题在使用 hexo 的时候引入 next 主题，这个是从另外一个项目中 clone 过来的。我们修改主题配置文件的时候，在根目录下执行 git status 会检查到 themes/next 下有变化，但是一套 git 操作下来，会发现我们的远程仓库中 themes/next 下的文件夹是空的，没有同步过去。 我们手动来添加我们修改的文件。 12&gt; git add themes/next/_config.ymlfatal: Pathspec 'themes/next/_config.yml' is in submodule 'themes/next' 看看 git 中 submodule 是个概念，解释 具体的 git submodule 解释，点击这里]]></content>
    </entry>

    
  
  
</search>
